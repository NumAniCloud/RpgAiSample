
なぜ単一責任の原則を守らなければならないのか？
つまり、なぜクラスには変更する理由が2つ以上あってはならないのか？

どのように、機能追加や修正がプログラムの他の部分へ広がっていくか？
どのように、可読性が低下するか？

```csharp
class A
{
    public void Responsibility1()
    {
        // 何かの処理1
    }
    public void Responsibility2()
    {
        // 何かの処理2
    }
}

class B
{
    public void Run(A a)
    {
        // 略：前処理
        a.Responsibility1();
        // 略：後処理
    }
}

class C
{
    public void Run(A a)
    {
        // 略：前処理
        a.Responsibility2();
        // 略：後処理
    }
}
```

何らかの仕様変更が起きて `Responsibility1` の実装が変わると、全体にどのような影響を及ぼす？

## ケース1
もし、「クラスAに仕様変更が起きた」ことがリリースノートで告知されたらどうなるか。
BもCも、「自分の使っているメソッドが変更されたかもしれないし、されなかったかもしれない」
という不安な状態になってしまう。
もし今後BやCのクラスに不具合が起きたら、Aの開発元に問い合わせなければならない。
クラスAが役割ごとに、クラスA1とクラスA2に分かれていれば、
そのような苦労をする必要があるクラスはBかCのどちらか一方だけだったはずだ。

ところで、リリースノートに「メソッド `A.Responsibility1` に仕様変更が起きた」という書き方をすれば、
Cの関わるソフトウェアに不具合が起きたときに、Aの開発元に問い合わせなくてよいはずである。
単一責任の原則をわざわざ守らず、運用でカバーするべきだったのか？
運用でカバーというのが人間の注意力を信用した考えなので、危うい方針であることは想像できる。

## ケース2
`A.Responsibility1` と `A.Responsibility2` が共通で使っている `A.Common` というメソッドがあるとする。
もし `A.Responsibility1` の責任についての仕様変更に対応するために `A.Common` が変更されたとしたら、
`A.Responsibility2` は不意に動作が変わってしまったことになる。
この状態で「`A.Responsibility1`が修正されました」というリリースノートを出すと、
`A.Responsibility2` を使っているユーザーがエラーを出した際、原因不明の難解なエラーとなる可能性がある。
クラスAが役割ごとに、クラスA1とクラスA2に分かれていれば、
そもそも `A.Common` の責任を持つクラス、たとえばCommonも、Common1とCommon2へと自然に分割されていたはずだ。

`A.Common` を書き換えたのだから、`A.Responsibility2`に影響がないつもりでリリースノートを出すのはおかしいと思えるかもしれない。
しかし鋭くそこに気づいたとしても、今度は`A.Responsibility2`を利用している部分に影響がないか
調べるという作業が待っているだけである。
クラスAが役割ごとに、クラスA1とクラスA2に分かれていれば、
`A.Responsibility1` を利用している部分に影響がないか調べるだけでよかったはずだ。

## ケース3
例えば `HttpGetClient` という名前のクラスがあるとして、
「HTTP GETを送信する」「HTTP HEADを送信する」という2つの役割を持っているとする。
いま、HTTP GETの機能に不具合が起きたとする。
この場合、クラス名を見れば `HttpGetClient` クラスが原因であることが簡単に推測できる。
では、HTTP HEADの機能に不具合が起きた場合はどうだろう。
この場合、クラス名を見るだけでは原因の場所を特定することができない。
最初から `HttpHeadClient` という別のクラスに分割していたら、
不具合の原因究明に要する時間が短縮できたはずだ。

## ケース4
`A.Responsibility1` と `A.Responsibility2` が共通で使っている `A.state` というフィールドがあるとする。
Aには元々`A.Responsibility1`メソッドだけがあったが、
後から`A.Responsibility2`が追加されたという経緯がある。
`A.Responsibility2`が追加された当時、
`A.Responsibility1` の処理で使っていた `A.state` の値が不正にならないよう、注意して実装された。
今ではこの2つの責務はお互いに不都合を及ぼさずに動いている。

ある日、`A.Responsibility2`の仕様が変更になった。
詳細は不明だが、今まで`A.state`を使っていたところが使わなくなったり、
逆に使っていなかったけれど新たに使うようになったりしたかもしれない。
あるいは、今までとは別の値を代入するようになったかもしれない。

どのケースでも構わないが、結局今回は`A.Responsibility1`を修正し、
`A.Responsibility2`の新しい実装と噛み合うようにすることとなった。
この場合、仕様変更があった `A.Responsibility2` だけでなく、
`A.Responsibility1` の動作確認もしなければならなくなる。

もしかしたら、`A.Responsibility1` は `A.state` を
元々使っていなくて今後も引き続き使わないのかもしれない。
それでも、`A.Responsibility1` が `A.state` を使っていないかどうかを確認するのは
ノーコストではない。

クラスAが役割ごとに、クラスA1とクラスA2に分かれていれば、
`A.Responsibility1` と `A.Responsibility2` が共通の変数を使用している可能性がなくなる。

## ケース5
`A.Responsibility1` の新たなバリエーション、 `A.Responsibility1B` が必要になった。
しかも、それを呼び出したいと思っている箇所も多いため、多態性を用いて解決しようと決まった。
今後、クラス`A`は新たなインターフェース`IA`を実装するクラスとなる。
`IA` の実装は次の通りだ。

```csharp
interface IA
{
    void Responsibility1();
}
```

`IA` の従来の実装 (名前は今まで通り、`A`) は次のようになる。実装は何も変わらないが、インターフェースを実装することが記述されている。

```csharp
class A : IA
{
    public void Responsibility1()
    {
        // 何かの処理1
    }
    public void Responsibility2()
    {
        // 何かの処理2
    }
}
```

`IA` の新しい実装 `ANext` は次のようになる。

```csharp
class ANext : IA
{
    public void Responsibility1()
    {
        // 何かの処理1 の新バージョンの実装
    }
    public void Responsibility2()
    {
        // 何かの処理2
    }
}
```

ここで注意すべきなのは、 `Responsibility2` の実装は何も変わっていないことである。
今回のように新たな実装を追加していくたびに、今までの実装をコピーしてくる手間になるし、
`A.Responsibility2` の実装が変わったら `ANext.Responsibility2` の実装にも反映しなければならない。
しかも、`A.Responsibility2`にも新たな実装を追加したくなったならば、
必要なクラスの数は4つに膨れ上がるし、
`A.Responsibility3`など、`A`の元々の責任が過剰であればあるほど、
二度手間やクラスの個数の爆発は手を付けられなくなっていく。

その時になって初めてクラスを分割したとしても、もしかしたら既に `A` を利用するクラスが膨大になっており、
コンパイルすることすら難しくなるかもしれない。